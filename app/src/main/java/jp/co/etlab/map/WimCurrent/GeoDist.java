package jp.co.etlab.map.WimCurrent;

public class GeoDist {
	// GRS80
	protected static final double a   = 6378137.0;		// [m]
	protected static final double f   = 1.0/298.257222101;

	protected static final double b   = a * (1 - f);
	protected static final double n   = f / (2 - f);
	protected static final double e2  = f * (2 - f);
	protected static final double e   = Math.sqrt(e2);
	protected static final double ep2 = f * (2 - f) / ((1 - f) * (1 - f));
	protected static final double ep  = Math.sqrt(ep2);

	protected static final double dblerror   = 2.22507385850720138309e-308;
	protected static final double dblepsilon = 2.22044604925031308085e-16;

	protected static final double M_PI       = 3.14159265358979323846;
	protected static final double M_PI_2     = 1.57079632679489661923;
	protected static final double M_PI2      = 6.28318530717958647693;

	double n1;
	double n2;
	double n3;
	double n4;
	double n5;
	double n6;
	double[] flat3s = new double[6];

	int tr1;
	int tr21;
	int tr22;
	int tr23;
	int tr3;
	int tr4;

	double lambda1_, phi1_, lambda2_, phi2_;
	int tr_;
	double cos_beta1_, sin_beta1_, tan_beta1_;
	double cos_beta2_, sin_beta2_, tan_beta2_;
	boolean equal_beta1_beta2_;
	double b22_b12_;	// cache

	/* work variables for Newton iteration */
	double alpha1_, cos_alpha1_, sin_alpha1_;
	double alpha2_, cos_alpha2_, sin_alpha2_;
	double[] e_;
	double I1_2m1_;
	double cos_alpha0_, sin_alpha0_;
	double sigma1_, cos_sigma1_, sin_sigma1_, cos2sigma1_, sin2sigma1_;
	double sigma2_, cos_sigma2_, sin_sigma2_, cos2sigma2_, sin2sigma2_;
	double s12_;

	public  GeoDist() {
		/* ----------------------------- I3 -----------------------------*/
		n1 = n;
		n2 = n1 * n1;
		n3 = n2 * n1;
		n4 = n3 * n1;
		n5 = n4 * n1;
		n6 = n5 * n1;
		flat3s[0] = n1;
		flat3s[1] = n2;
		flat3s[2] = n3;
		flat3s[3] = n4;
		flat3s[4] = n5;
		flat3s[5] = n6;

	}
	protected boolean dbl_equal(double val, double base) {
		if (val == base) {
			return true;
		} else {
			double absdiff = Math.abs(val - base);
			if (absdiff > dblerror) {
				return false;
			} else {
				double absbase = Math.abs(base);
				return absbase <= dblerror
					? true
					: absdiff <= dblepsilon * absbase;
			}
		}
	}

	protected double fmod(double x, double y){ // y must be positive.
		boolean neg = false;
		if (x < 0) { x = -x; neg = true; }
		x = x - Math.floor(x / y) * y;
		return neg ? -x : x;
	}

	protected double cos2x(double cosx, double sinx) {
		return cosx * cosx - sinx * sinx;
	}
	protected double sin2x(double cosx, double sinx) {
		return 2 * cosx * sinx;
	}

	protected double[] reduced_latitude(double phi)
	{
		double data[] = new double[3];
		double cos_beta = Math.cos(phi);
		double sin_beta = (1 - f) * Math.sin(phi);
		double denom = Math.sqrt(cos_beta * cos_beta + sin_beta * sin_beta);
		cos_beta /= denom;
		sin_beta /= denom;
		data[0] = cos_beta;
		data[1] = sin_beta;
		data[2] = sin_beta / cos_beta;
		return data;
	}
	protected double[] alpha0(double cos_alpha, double sin_alpha, double cos_beta, double sin_beta)	{
		double data[] = new double[2];
		double x2 = cos_alpha * cos_alpha;
		double y  = sin_alpha * sin_beta;
		data[0]=Math.sqrt(x2 + y * y);
		data[1]=sin_alpha * cos_beta;
		return data;
	}
	protected double[] sigma(double cos_alpha, double tan_beta) 	{
		double data[] = new double[3];
		double denom = Math.sqrt(tan_beta * tan_beta + cos_alpha * cos_alpha);
		double sin_sigma = tan_beta  / denom;
		double cos_sigma = cos_alpha / denom;
		data[0]=cos_sigma;
		data[1]=sin_sigma;
		data[2]=Math.atan2(sin_sigma, cos_sigma);
		return data;
	}

	protected double[] normalize_coordinate(double lambda, double phi) 	{
		double data[] = new double[2];
		if (lambda < -M_PI) {
			if (lambda < -M_PI2) {
				lambda = fmod(lambda, M_PI2);
			}
			lambda += M_PI2;
		} else if (M_PI < lambda) {
			if (lambda >  M_PI2) {
				lambda = fmod(lambda, M_PI2);
			}
			lambda -= M_PI2;
		}

		if (phi < -M_PI_2) {
			if (phi < -M_PI2) {
				phi = fmod(phi, M_PI2);
			}
			phi = (phi < -M_PI_2*3)
				? phi + M_PI2 : -(phi + M_PI);
		} else if (M_PI_2 < phi) {
			if (phi >  M_PI2) {
				phi = fmod(phi, M_PI2);
			}
			phi = (phi >  M_PI_2*3)
				? phi - M_PI2 : -(phi - M_PI);
		}

		data[0]=lambda;
		data[1]=phi;
		return data;
	}


	/* generated by maxima begin {*/
	public static final int Order = 6;
	protected void epsilons(double cos_alpha0, double[] eps)
	{
		double k = ep * cos_alpha0;
		double sqrtk1 = Math.sqrt(1 + k * k) + 1;
		double eps0 = k * k / (sqrtk1 * sqrtk1);
		eps[0] = eps0;
		eps[1] = eps[0] * eps0;
		eps[2] = eps[1] * eps0;
		eps[3] = eps[2] * eps0;
		eps[4] = eps[3] * eps0;
		eps[5] = eps[4] * eps0;
	}
	protected double calcB(
		double C1,
		double C2,
		double C3,
		double C4,
		double C5,
		double C6,
		double cos2x, double sin2x, boolean truncate)
	{
		cos2x *= 2;
		double b6 = C6;
		double b5 = C5 + b6 * cos2x;
		double b4 = C4 + b5 * cos2x - b6;
		double b3 = C3 + b4 * cos2x - b5;
		double b2 = C2 + b3 * cos2x - b4;
		return !truncate
			? (C1 + b2 * cos2x - b3) * sin2x : b2 * sin2x;
	}

	/* ----------------------------- I1 -----------------------------*/
	protected double calcA1(double eps2, double eps1)
	{
		return (eps2*(eps2*(eps2+4)+64)+256)/(256*(1-eps1));
	}
	protected void calcC1(double[] eps, double[] C)
	{
		double eps2 = eps[1];
		C[0] = (((6-eps2)*eps2-16)/32) * eps[0];
		C[1] = (((64-9*eps2)*eps2-128)/2048) * eps[1];
		C[2] = ((9*eps2-16)/768) * eps[2];
		C[3] = ((3*eps2-5)/512) * eps[3];
		C[4] = (-7/1280) * eps[4];
		C[5] = (-7/2048) * eps[5];
	}
	protected double calcI1(double[] eps, double sigma, double cos2x, double sin2x)
	{
		//var C = new Float64Array(Order);
		double[] C = new double[Order];
		calcC1(eps, C);
		return calcA1(eps[1], eps[0]) * (sigma + calcB(
				C[0],
				C[1],
				C[2],
				C[3],
				C[4],
				C[5],
				cos2x, sin2x, false));
	}
	protected double calcI1diff(double[] eps, double sigma2, double cos2x2, double sin2x2, double sigma1, double cos2x1, double sin2x1)
	{
		//var C = new Float64Array(Order);
		double[] C = new double[Order];
		calcC1(eps, C);
		return calcA1(eps[1], eps[0]) * (  (sigma2 + calcB(
					C[0],
					C[1],
					C[2],
					C[3],
					C[4],
					C[5],
					cos2x2, sin2x2, false))
				- (sigma1 + calcB(
					C[0],
					C[1],
					C[2],
					C[3],
					C[4],
					C[5],
					cos2x1, sin2x1, false)));
	}

	/* ------------------------- I1 reversion -----------------------*/
	protected double calcRevertI1(double[] eps, double s) 	{
		double eps2 = eps[1];
		double tau = s / (b * calcA1(eps2, eps[0]));
		return tau + calcB(
			((eps2*(205*eps2-432)+768)/1536)*eps[0],
			((eps2*(4005*eps2-4736)+3840)/12288)*eps[1],
			((116-225*eps2)/384)*eps[2],
			((2695-7173*eps2)/7680)*eps[3],
			(3467/7680)*eps[4],
			(38081/61440)*eps[5],
			Math.cos(2*tau), Math.sin(2*tau), false);
	}

	/* ----------------------------- I2 -----------------------------*/
	protected double calcA2(double eps2, double eps1)
	{
		return ((eps2*(eps2*(25*eps2+36)+64)+256)/256)*(1-eps1);
	}
	protected void calcC2(double[] eps, double[] C)
	{
		double eps2 = eps[1];
		C[0] = ((eps2*(eps2+2)+16)/32) * eps[0];
		C[1] = ((eps2*(35*eps2+64)+384)/2048) * eps[1];
		C[2] = ((15*eps2+80)/768) * eps[2];
		C[3] = ((7*eps2+35)/512) * eps[3];
		C[4] = (63/1280) * eps[4];
		C[5] = (77/2048) * eps[5];
	}
	protected double calcI2(double[] eps, double sigma, double cos2x, double sin2x)	{
		//var C = new Float64Array(Order);
		double[] C = new double[Order];
		calcC2(eps, C);
		return calcA2(eps[1], eps[0]) * (sigma + calcB(
				C[0],
				C[1],
				C[2],
				C[3],
				C[4],
				C[5],
				cos2x, sin2x, false));
	}
	protected double calcI2diff(double[] eps, double sigma2, double cos2x2, double sin2x2, double sigma1, double cos2x1, double sin2x1)
	{
		//var C = new Float64Array(Order);
		double[] C = new double[Order];
		calcC2(eps, C);
		return calcA2(eps[1], eps[0]) * (  (sigma2 + calcB(
					C[0],
					C[1],
					C[2],
					C[3],
					C[4],
					C[5],
					cos2x2, sin2x2, false))
				- (sigma1 + calcB(
					C[0],
					C[1],
					C[2],
					C[3],
					C[4],
					C[5],
					cos2x1, sin2x1, false)));
	}

	protected double calcA3(double eps1) 	{
		return (eps1*(eps1*(eps1*((-8*n1-24)*n1+eps1*(-4*n1-3*eps1-6)-8)+n1*(48*n1-16)-32)+64*n1-64)+128)/128;
	}
	protected void calcC3(double[] eps, double[] C)
	{
		double eps1 = eps[0];

		C[1] = ((eps1*(-16*n2+eps1*(eps1*(2*n1+3*eps1+5)+(6-2*n1)*n1+6)+16)-32*n1+32)/128) * eps[0];
		C[2] = ((eps1*(eps1*(2*n1+5*eps1+6)+(-12*n1-8)*n1+12)+n1*(8*n1-24)+16)/256) * eps[1];
		C[3] = ((n1*(40*n1-72)+eps1*(-40*n1+21*eps1+36)+40)/1536) * eps[2];
		C[4] = ((-14*n1+7*eps1+7)/512) * eps[3];
		C[5] = (21/2560) * eps[4];
	}
	protected double calcI3(double[] eps, double sigma, double cos2x, double sin2x)
	{
		//var C = new Float64Array(Order);
		double[] C = new double[Order];
		calcC3(eps, C);
		return calcA3(eps[0]) * (sigma + calcB(0,
			C[1],
			C[2],
			C[3],
			C[4],
			C[5],
			cos2x, sin2x, true));
	}
	protected double calcI3diff(double[] eps, double sigma2, double cos2x2, double sin2x2, double sigma1, double cos2x1, double sin2x1)
	{
		//var C = new Float64Array(Order);
		double[] C = new double[Order];
		calcC3(eps, C);
		return calcA3(eps[0]) * (  (sigma2 + calcB(0,
					C[1],
					C[2],
					C[3],
					C[4],
					C[5],
					cos2x2, sin2x2, true))
				- (sigma1 + calcB(0,
					C[1],
					C[2],
					C[3],
					C[4],
					C[5],
					cos2x1, sin2x1, true)));
	}

	/* } generated by maxima end */

	public double[] solve_direct_problem(double lambda1, double phi1, double s12, double alpha1) {
		double alpha2;
		double phi2;
		double[] val = normalize_coordinate(lambda1, phi1);
		lambda1 = val[0];
		phi1    = val[1];

		double lambda2;
		if (dbl_equal(Math.abs(phi1), M_PI_2)) {
			// (lambda1, phi1) is one of the poles.
			lambda2 = lambda1 + alpha1;
			double s1 = b * calcA1(n2, n1) * phi1;
			double sigma2 = calcRevertI1(flat3s, s1 + s12);
			phi2 = Math.atan2(Math.sin(sigma2), (1-f)*Math.cos(sigma2));

			if (Math.abs(sigma2) > M_PI2) {
				sigma2 = fmod(sigma2, M_PI2);
			}
			if (-M_PI_2 <= sigma2 && sigma2 <= M_PI_2) {
				alpha2 = phi1 > 0 ? M_PI : 0;
			} else {
				alpha2 = phi1 > 0 ? 0 : M_PI;
				lambda2 += M_PI;
			}
			return retDirect(lambda2,phi2,alpha2);

		} else if (dbl_equal(phi1, 0) && dbl_equal(Math.abs(alpha1), M_PI_2)) {
			// s12 is a part of the equator.
			double dl = s12 / a;
			lambda2 = (alpha1 > 0) ? (lambda1 + dl) : (lambda1 - dl);
			phi2 = 0;
			alpha2 = alpha1;
			return retDirect(lambda2,phi2,alpha2);
		}

		val = reduced_latitude(phi1);
		double cos_beta1 = val[0];
		double sin_beta1 = val[1];
		double tan_beta1 = val[2];

		double cos_alpha1 = dbl_equal(alpha1, M_PI_2) ? 0 : Math.cos(alpha1);
		double sin_alpha1 = dbl_equal(alpha1, -M_PI)  ? 0 : Math.sin(alpha1);
		val = alpha0(cos_alpha1, sin_alpha1, cos_beta1, sin_beta1);
		double cos_alpha0 = val[0];
		double sin_alpha0 = val[1];

		val = sigma(cos_alpha1, tan_beta1);
		double cos_sigma1 = val[0];
		double sin_sigma1 = val[1];
		double sigma1     = val[2];

		//var epsilon = new Float64Array(Order);
		double[] epsilon = new double[Order];
		epsilons(cos_alpha0, epsilon);
		double cos2sigma1 = cos2x(cos_sigma1, sin_sigma1);
		double sin2sigma1 = sin2x(cos_sigma1, sin_sigma1);
		double s1 = b * calcI1(epsilon, sigma1, cos2sigma1, sin2sigma1);

		double omega1 = Math.atan2(sin_alpha0 * sin_sigma1, cos_sigma1);

		double sigma2 = calcRevertI1(epsilon, s1 + s12);
		double cos_sigma2 = Math.cos(sigma2);
		double sin_sigma2 = Math.sin(sigma2);

		double x = sin_alpha0;
		double y = cos_alpha0 * cos_sigma2;
		double cos_beta2 = Math.sqrt(x * x + y * y);
		double sin_beta2 = cos_alpha0 * sin_sigma2;
		alpha2    = Math.atan2(sin_alpha0, cos_alpha0 * cos_sigma2);
		double omega2    = Math.atan2(sin_alpha0 * sin_sigma2, cos_sigma2);

		phi2 = Math.atan2(sin_beta2, (1 - f) * cos_beta2);

		double cos2sigma2 = cos2x(cos_sigma2, sin_sigma2);
		double sin2sigma2 = sin2x(cos_sigma2, sin_sigma2);
		lambda2 = lambda1
			+ (omega2 - omega1) - f * sin_alpha0
				* calcI3diff(epsilon,
					sigma2, cos2sigma2, sin2sigma2,
					sigma1, cos2sigma1, sin2sigma1);
		return retDirect(lambda2,phi2,alpha2);
	}
	private double[] retDirect(double lambda2, double phi2, double alpha2) {
		double[] val = normalize_coordinate(lambda2, phi2);
		val[2]=alpha2;
		return val;
	}

	public double[] solve_inverse_problem(double lambda1, double phi1, double lambda2, double phi2)
	{
		tr1  = 0;
		tr21 = 1<<0;
		tr22 = 1<<1l;
		tr23 = 1<<3;
		tr3  = 1<<4;
		tr4  = 1<<5;

		/* work variables for Newton iteration */
		e_ = new double[Order];

		config_endpoints(lambda1, phi1, lambda2, phi2);
		double[] val=new double[2];
		val = reduced_latitude(phi1_);
		cos_beta1_ = val[0]; sin_beta1_ = val[1]; tan_beta1_ = val[2];
		val = reduced_latitude(phi2_);
		cos_beta2_ = val[0]; sin_beta2_ = val[1]; tan_beta2_ = val[2];

		equal_beta1_beta2_ = dbl_equal(cos_beta2_, cos_beta1_);
		b22_b12_ = (tan_beta1_ > -1)
			? (cos_beta2_ - cos_beta1_) * (cos_beta2_ + cos_beta1_)
			: (sin_beta1_ - sin_beta2_) * (sin_beta1_ + sin_beta2_);

		return solve();
	}

	private void config_endpoints(double lambda1, double phi1, double lambda2, double phi2) {
		double[] val = new double[2];
		val = normalize_coordinate(lambda1, phi1);
		lambda1_ = val[0]; phi1_ = val[1];

		val = normalize_coordinate(lambda2, phi2);
		lambda2_ = val[0]; phi2_ = val[1];

		double lambda12 = lambda2_ - lambda1_;
		tr_ = tr1;
		if (lambda12 < -M_PI) {
			lambda12 = M_PI2 + lambda12;
			tr_ |= tr21;
		} else if (-M_PI <= lambda12 && lambda12 < 0) {
			lambda12 = -lambda12;
			tr_ |= tr22;
		} else if (0 <= lambda12 && lambda12 <= M_PI) {
			// do nothing
		} else if (M_PI < lambda12) {
			lambda12 = M_PI2 - lambda12;
			tr_ |= tr23;
		}
		lambda1_ = 0;
		lambda2_ = lambda12;

		if (Math.abs(phi1_) < Math.abs(phi2_)) {
			double tmp = phi1_; phi1_ = phi2_; phi2_ = tmp;
			tr_ |= tr3;
		}
		if (phi1_ > 0) {
			phi1_ = -phi1_; phi2_ = -phi2_;
			tr_ |= tr4;
		}
	}

	private void calc_sphere_alpha1(double cos_omega12, double sin_omega12) {
		double sin_omega122 = sin_omega12 * sin_omega12;
		double sb1cb2 = sin_beta1_ * cos_beta2_;
		double sb2cb1 = sin_beta2_ * cos_beta1_;
		double sb2m1 = sb2cb1 - sb1cb2;
		double sb2p1 = sb2cb1 + sb1cb2;

		double R1 = cos_omega12 >= 0
			? sb2m1 + sb1cb2 * sin_omega122 / (1 + cos_omega12)
			: sb2p1 - sb1cb2 * sin_omega122 / (1 - cos_omega12);
		alpha1_ = Math.atan2(cos_beta2_ * sin_omega12, R1);
		cos_alpha1_ = Math.cos(alpha1_);
		sin_alpha1_ = Math.sin(alpha1_);
	}
	private void calc_sphere_alpha2(double cos_omega12, double sin_omega12) {
		double sin_omega122 = sin_omega12 * sin_omega12;
		double sb1cb2 = sin_beta1_ * cos_beta2_;
		double sb2cb1 = sin_beta2_ * cos_beta1_;
		double sb2m1 = sb2cb1 - sb1cb2;
		double sb2p1 = sb2cb1 + sb1cb2;

		double R2 = cos_omega12 <= 0
			?  sb2p1 + sb2cb1 * sin_omega122 / (1 - cos_omega12)
			: -sb2m1 + sb2cb1 * sin_omega122 / (1 + cos_omega12);
		alpha2_ = Math.atan2(cos_beta1_ * sin_omega12, R2);
		cos_alpha2_ = Math.cos(alpha2_);
		sin_alpha2_ = Math.sin(alpha2_);
	}
	private double calc_sphere_sigma12(double cos_omega12, double sin_omega12) {
		double sin_omega122 = sin_omega12 * sin_omega12;
		double sb1cb2 = sin_beta1_ * cos_beta2_;
		double sb2cb1 = sin_beta2_ * cos_beta1_;
		double sb2m1 = sb2cb1 - sb1cb2;
		double sb2p1 = sb2cb1 + sb1cb2;

		double R1 = cos_omega12 >= 0
			? sb2m1 + sb1cb2 * sin_omega122 / (1 + cos_omega12)
			: sb2p1 - sb1cb2 * sin_omega122 / (1 - cos_omega12);

		double x = cos_beta2_ * sin_omega12;
		double y = R1;
		return Math.atan2(Math.sqrt(x * x + y * y),
			cos_beta1_ * cos_beta2_ * cos_omega12
					+ sin_beta1_ * sin_beta2_);
	}

	private double calc_reduced_length() {
		double I2_2m1 = calcI2diff(e_,
			sigma2_, cos2sigma2_, sin2sigma2_,
			sigma1_, cos2sigma1_, sin2sigma1_);
		double J_2m1 = I1_2m1_ - I2_2m1;
		double y1 = ep * cos_alpha0_ * sin_sigma1_;
		double y2 = ep * cos_alpha0_ * sin_sigma2_;
		double w1 = Math.sqrt(1 + y1 * y1);
		double w2 = Math.sqrt(1 + y2 * y2);
		return b * (
			  w2 * cos_sigma1_ * sin_sigma2_
			- w1 * cos_sigma2_ * sin_sigma1_
			- cos_sigma1_ * cos_sigma2_ * J_2m1);
	}
	private double Newton_derivative() {
		if (!equal_beta1_beta2_ || !dbl_equal(cos_alpha1_, 0)) {
			return calc_reduced_length()
				/ (a * cos_alpha2_ * cos_beta2_);
		} else {
			double x = b/a/sin_beta1_;
			return - 2 * Math.sqrt(x * x + e2);
		}
	}

	private void calc_antipodal_alpha1(double x, double y) {
		double x2 = x*x, y2 = y*y;
		double r = (x2 + y2 - 1) / 6;
		double kappa = 0;
		if (!dbl_equal(x, 0) || r > 0) {
			double r2 = r*r, r3 = r2 * r;
			double S = x2 * y2 / 4;
			double d = S * (S + 2 * r3);
			double u;
			double T = S + r3;
			if (d >= 0) {
				T += (T >= 0 ? Math.sqrt(d) : -Math.sqrt(d));
				T = Math.pow(T, 1/3);
				u = r + T + r2 / T;
			} else {
				double psi = Math.atan2(-Math.sqrt(-d), T);
				u = r * (1 + 2 * Math.cos(psi / 3));
			}
			double v = Math.sqrt(u * u + y * y);
			double vpu = u >= 0 ? v + u : y2 / (v - u);
			double w = (vpu - y2) / (2 * v);
			kappa = vpu / (Math.sqrt(vpu + w*w) + w);
		}

		alpha1_ = Math.atan2(-y/kappa, -x/(1+kappa)) + M_PI_2;
		cos_alpha1_ = Math.cos(alpha1_);
		sin_alpha1_ = Math.sin(alpha1_);
	}
	private double calc_w12() {
		double c = (cos_beta1_+cos_beta2_)/2;
		return Math.sqrt(1 - e2 * c * c);
	}
	private boolean Newton_init() {
		double sb2m1 = sin_beta2_ * cos_beta1_ - cos_beta2_ * sin_beta1_;

		if (lambda2_ < M_PI/6 && sb2m1 < 0.5) {
			double w12 = calc_w12();
			double omega12 = lambda2_ / w12;
			double co12 = Math.cos(omega12);
			double so12 = Math.sin(omega12);
			double sigma12 = calc_sphere_sigma12(co12, so12);
			if (sigma12 < 100 * Math.sqrt(dblepsilon)) {
				calc_sphere_alpha1(co12, so12);
				calc_sphere_alpha2(co12, so12);
				s12_ = a * w12 * sigma12;
				return true;
			} else {
				calc_sphere_alpha1(co12, so12);
				return false;
			}
		}

		double omega12 = lambda2_;
		double co12 = Math.cos(omega12);
		double so12 = Math.sin(omega12);
		double sigma12 = calc_sphere_sigma12(co12, so12);
		calc_sphere_alpha1(co12, so12);

		double[] val;
		val = alpha0(cos_alpha1_, sin_alpha1_, cos_beta1_, sin_beta1_);
		cos_alpha0_ = val[0]; sin_alpha0_ = val[1];
		epsilons(cos_alpha0_, e_);

		double Delta = f * M_PI * calcA3(e_[0]) * cos_beta1_;
		if (sigma12 <= M_PI - 3 * Delta * cos_beta1_) {
			// do nothing
		} else {
			double x = (lambda2_ - M_PI) / Delta;
			double beta1 = Math.atan2(sin_beta1_, cos_beta1_);
			double beta2 = Math.atan2(sin_beta2_, cos_beta2_);
			double y = (beta2 + beta1) / (cos_beta1_ * Delta);

			if (y > -100 * dblepsilon
			 && x > -1 - 1000 * Math.sqrt(dblepsilon)) {
				sin_alpha1_ = Math.min(1.0, -x);
				cos_alpha1_ = -Math.sqrt(
						1 - sin_alpha1_*sin_alpha1_);
				alpha1_ = Math.atan2(sin_alpha1_, cos_alpha1_);
			} else {
				calc_antipodal_alpha1(x, y);
			}
		}
		return false;
	}

	private double solve_direct_variant() {
		cos_alpha1_ = Math.cos(alpha1_);
		sin_alpha1_ = Math.sin(alpha1_);
		if (!dbl_equal(phi1_, 0)) {
			double[] val = alpha0(cos_alpha1_, sin_alpha1_,
					 cos_beta1_,  sin_beta1_);
			cos_alpha0_ = val[0]; sin_alpha0_ = val[1];

			cos_alpha2_ = Math.sqrt(
				  cos_alpha1_ * cos_alpha1_
				* cos_beta1_ * cos_beta1_
				+ b22_b12_) / cos_beta2_;
			sin_alpha2_ = sin_alpha0_ / cos_beta2_;
			alpha2_ = Math.atan2(sin_alpha2_, cos_alpha2_);
		} else {
			cos_alpha1_ =  Math.abs(cos_alpha1_);
			cos_alpha0_ =  cos_alpha1_;
			sin_alpha0_ =  sin_alpha1_;
			cos_alpha2_ = -cos_alpha1_;
			sin_alpha2_ =  sin_alpha1_;
			alpha2_ = M_PI - alpha1_;
		}

		double val[] = sigma(cos_alpha1_, tan_beta1_);
		cos_sigma1_ = val[0]; sin_sigma1_ = val[1]; sigma1_ = val[2];
		double omega1 = Math.atan2(sin_alpha0_ * tan_beta1_, cos_alpha1_);

		sigma2_ = Math.atan2(tan_beta2_, cos_alpha2_);
		double tan_sigma2 = tan_beta2_ / cos_alpha2_;
		cos_sigma2_ = 1 / Math.sqrt(1 + tan_sigma2 * tan_sigma2);
		sin_sigma2_ = tan_sigma2 * cos_sigma2_;
		double omega2 = Math.atan2(sin_alpha0_ * tan_beta2_, cos_alpha2_);

		epsilons(cos_alpha0_, e_);
		cos2sigma1_ = cos2x(cos_sigma1_, sin_sigma1_);
		sin2sigma1_ = sin2x(cos_sigma1_, sin_sigma1_);
		cos2sigma2_ = cos2x(cos_sigma2_, sin_sigma2_);
		sin2sigma2_ = sin2x(cos_sigma2_, sin_sigma2_);

		return (omega2 - omega1)
			 - f * sin_alpha0_ * calcI3diff(e_,
				sigma2_, cos2sigma2_, sin2sigma2_,
				sigma1_, cos2sigma1_, sin2sigma1_);
	}

	private double[] calc_azimuth(double a1, double a2) {
		double val[] = new double[2];
		if ((tr_ & tr4)!=0) {
			a1 = M_PI - a1;
			a2 = M_PI - a2;
		}
		if ((tr_ & tr3)!=0) {
			double tmp_a1 = M_PI - a2;
			double tmp_a2 = M_PI - a1;
			a1 = tmp_a1;
			a2 = tmp_a2;
		}
		if ((tr_ & tr21)!=0) {
			// do nothing
		} else if ((tr_ & tr22)!=0) {
			a1 = -a1;
			a2 = -a2;
		} else if ((tr_ & tr23)!=0) {
			// do nothing
		}
		val[0] = a1;
		val[1] = a2;
		return val;
	}

	private double[] case_meridian() {
		double val[] = new double[3];
		if (dbl_equal(lambda2_, 0)) {
			alpha1_     = 0;
			cos_alpha1_ = 1;
			sin_alpha1_ = 0;
			cos_sigma1_ = cos_beta1_;
			sin_sigma1_ = sin_beta1_;
			sigma1_     = Math.atan2(sin_sigma1_, cos_sigma1_);
		} else {
			alpha1_     = M_PI;
			cos_alpha1_ = -1;
			sin_alpha1_ = 0;
			cos_sigma1_ = -cos_beta1_;
			sin_sigma1_ =  sin_beta1_;
			sigma1_     = dbl_equal(phi1_, 0)
				? -M_PI
				: Math.atan2(sin_sigma1_, cos_sigma1_);
		}

		alpha2_     = 0;
		cos_alpha2_ = 1;
		sin_alpha2_ = 0;
		cos_sigma2_ = cos_beta2_;
		sin_sigma2_ = sin_beta2_;

		cos2sigma1_ = cos2x(cos_sigma1_, sin_sigma1_);
		sin2sigma1_ = sin2x(cos_sigma1_, sin_sigma1_);

		sigma2_     = Math.atan2(sin_sigma2_, cos_sigma2_);
		cos2sigma2_ = cos2x(cos_sigma2_, sin_sigma2_);
		sin2sigma2_ = sin2x(cos_sigma2_, sin_sigma2_);

		epsilons(1, e_);
		I1_2m1_ = calcI1diff(e_,
				sigma2_, cos2sigma2_, sin2sigma2_,
				sigma1_, cos2sigma1_, sin2sigma1_);
		//return [b * I1_2m1_, alpha1_, alpha2_];
		val[0] = b * I1_2m1_;
		val[1] = alpha1_;
		val[2] = alpha2_;
		return val;
	}
	private double[] case_equator() {
		double val[] = new double[3];
		//return [a * (lambda2_ - lambda1_), M_PI_2, M_PI_2];
		val[0] = a * (lambda2_ - lambda1_);
		val[1] = M_PI_2;
		val[2] = M_PI_2;
		return val;
	}

	private double[] solve() {
		double val[] = new double[3];
		double lambda12 = lambda2_;
		if (lambda12!=0) {
			lambda12 = fmod(lambda12, M_PI);
		}
		if (dbl_equal(lambda12, 0) || dbl_equal(phi1_, -M_PI_2)) {
			return retSolve(case_meridian());
		}
		if (dbl_equal(phi1_, phi2_)
		 && dbl_equal(phi1_, 0)
		 && lambda2_ <= (1 - f) * M_PI) {
			return retSolve(case_equator());
		}

		if (Newton_init()) {
			//return retSolve([s12_, alpha1_, alpha2_]);
			val[0] = s12_;
			val[1] = alpha1_;
			val[2] = alpha2_;
			return retSolve(val);
		}

		boolean end = false;
		for (int limit = 0; limit < 50; limit++) {
			double dy = solve_direct_variant() - lambda2_;
			I1_2m1_ = calcI1diff(e_,
				sigma2_, cos2sigma2_, sin2sigma2_,
				sigma1_, cos2sigma1_, sin2sigma1_);

			if (end) { break; }

			double dx = Newton_derivative();
			double dlt = dy /dx;
			double org = alpha1_;
			alpha1_ -= dlt;

			if (Math.abs(dlt)
			 <= Math.sqrt(dblepsilon) / (1<<10) * Math.abs(org)) {
				end = true;
			}
		}
		//return retSolve([b * I1_2m1_, alpha1_, alpha2_]);
		val[0] = b * I1_2m1_;
		val[1] = alpha1_;
		val[2] = alpha2_;
		return retSolve(val);
	}
	private double[] retSolve(double[] retval) {
		double val[] = calc_azimuth(retval[1], retval[2]);
		retval[1] = val[0]; retval[2] = val[1];
		return retval;
	}

	public double deg2rad(double deg) {
		return deg / 180 * M_PI;
	}
	public double rad2deg(double rad) {
		return rad / M_PI * 180;
	}
}